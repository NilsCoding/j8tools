# j8tools *by NilsCoding*This is just a simple collection - or you might call it "playground" - for classes which utilize some of the new features of Java 8, mostly related to streams.## DisclaimerAs stated by the license below, this code comes without any warranty, so you might not want to use it in production. This is just a technical playground so some of the code might violate "best practices" or even prerequisites of the Java Stream framework. You have been warned!# Some examples and background informationAs you might know, Java 8 introduces the concept of Streams - in short: a source of objects, provided by a collection or a generator. Like in C#, streams in Java can be filtered and mapped, and they are only consumed if requested. Please note that if a stream was consumed, it cannot be reused and a new stream must be acquired from the source.## Example for creating a stream from a list```javaList<String> list = Arrays.asList("A", "B", "C", "D");Stream<String> stream = list.stream();```## Example for consuming a stream```java// number of elementslong count = list.stream().count();// print each elementlist.stream().forEach(System.out::println);// alternative syntax for printing each elementlist.stream().forEach(s -> System.out.println(s));// even more verbose SyntaxConsumer<String> sysOut = s -> System.out.println(s);list.stream().forEach(sysOut);```# ConsumersSimply speaking, a `Consumer` is the final target of elements that are provided by the stream. In the code example above `s -> System.out.println(s)` can be considered as the `Consumer`. And as you can also see there, it can be written as a `Consumer` object.So, why not have some more predefined consumers? These are just some examples from j8tools.## CountingConsumerCounts how many elements were consumed.```javaCountingConsumer<String> counter = new CountingConsumer<>(System.out::println);list.stream().forEach(counter);System.out.println("number of elements processed: " + counter.getCount());```## RoundRobinConsumerForwards each element to one of the given consumers, in a Round-Robin fashion.```javaRoundRobinConsumer<String> roundRobin = new RoundRobinConsumer<>(        s -> System.out.println("1: " + s),        s -> System.out.println("2: " + s));list.stream().forEach(roundRobin);```## other notable Consumers* `DiscardingConsumer`: Discards every element* `RandomDistributionConsumer`: Forwards each element to one of the given `Consumer`s, chosen randomly* `RandomlyDiscardingConsumer`: Forwards the elements to the given `Consumer`, but randomly discards an element (around 50% are discarded)* `SplittingConsumer`: Forwards each element to all the given `Consumer`s# SupplierThe source of the stream can also be a `Supplier`, which is something like a generator. It can either generate an infinite number of elements, or a limited one. Most of the `Supplier`s in j8tools are just wrappers around other `Supplier`s or produce an infinite number of elements.## NthIntegerSupplierProvides Integer values, starting with 0, increasing by 1.Two other constructors allow to specify a different start value and/or an (exclusive) maximum value.```javaStream<Integer> numbers = Stream.generate(new NthIntegerSupplier());// print first 10 numbers from streamnumbers.limit(10).forEach(System.out::println);```## PrimeLongSupplierProvides prime numbers. Please be aware that the bigger the numbers become, the longer it will take to provide the next prime.```javaStream<Long> primes = Stream.generate(new PrimeLongSupplier());// print first 30 prime numbers from streamprimes.limit(30).forEach(System.out::println);```## other notable Suppliers* `CountingSupplier`: Wraps an existing `Supplier` and counts how many elements have been supplied* `DelayingSupplier`: Returns values from another `Supplier`, but only fetches values from it every n-th call ("delaying" calls to its source `Supplier`) * `FibonacciLongSupplier`: Provides a sequence of Fibonacci numbers* `ForwardingSupplier`: Wraps an existing `Supplier` and forwards each element to a `Consumer`* `Increasing[Date/Time]Supplier`: Returns date/time related values* `InfiniteInstanceSupplier`: Provides the given object infinitive* `RepeatingSupplier`: Repeats the given elements infinitive* `MutationSupplier`: Mutates / combines given elements, see belowSome `Supplier`s also have copies that are implemented to work with primitive values. This is due to the different handling e.g. of `Supplier<Integer>` and `IntSupplier` in the Java Stream framework.# Notable implementationsSome classes in this project might seem not to really fit in here. But this is a playground, so I added them anyway.## MutationSupplierCreates a sequence of "increasing" combined values from a given source of elements. Somehow hard to explain, so here's an example:```java// source objectsList<String> srcElements = Arrays.asList("A", "B", "C");// create the MutatorMutator<CharSequence,?,String> strMutator = new Mutator(srcElements, Collectors.joining());// create Supplier for MutatorMutationSupplier<CharSequence,?,String> supplier = new MutationSupplier<>(strMutator);// consume 20 elementsStream.generate(supplier).limit(20).forEach(e -> {    System.out.print("" + e + "  ");});```This will output the sequence:```A  B  C  AA  AB  AC  BA  BB  BC  CA  CB  CC  AAA  AAB  AAC  ABA  ABB  ABC  ACA  ACB```The `Mutator` takes each source element (ordered) and builds an increasing sequence. When each element has been used, the first element is taken again and combined with each of the elements, then the second element with all elements and so on.The `Collector` expected as a parameter is used to combine the single "row elements" into resulting elements, in this example they are concatenated to a String.## Facets / FacettingConsumerLet's say, you have some objects of type `Person` with attributes like `city` and `age`.If you want to count how many persons live in each city and how many people are how many years old, then you need to somehow group and count those attribute values.And this is where the `FacettingConsumer` is here to make your life easier.```javaFacettingConsumer<Person> fcp = new FacettingConsumer<>(        StandardFacet::new,        new MethodFieldAccessor<>("city", Person::getCity),        new MethodFieldAccessor<>("age", Person::getAge));listOfPersons.stream()        .peek(fcp)        .forEach(new DiscardingConsumer<>());Facets facets = fcp.getFacets();IFacet fcCity = facets.getFacetByName("city");List<FacetValue> fcCityValues = fcCity.getFacetValues();IFacet fcAge = facets.getFacetByName("age");List<FacetValue> fcAgeValues = fcAge.getFacetValues();```The `FacetConsumer<T>` expects a creation method for a facet implementation. If you don't need any special behaviour, you can go with `StandardFacet::new` here.Then you need to specify how values should be grouped. You can use annotations in your data class, but the most flexible way is using the `MethodFieldAccessor` which needs a name for the facet (just some String value to later get the values) and a `Function` to get the attribute value from an object.Optionally, you can provide another function which transforms the attribute value before using it as a facet value. For example, you can use this to reduce a name to the first character and use that character as facet attribute value._Implementation note_: If you use the `AnnotationBasedAccessor`, then all other types of accessors specified there are ignored. This is because the annotations specify which fields to use and that might interfere with other accessors.To "fill" the facets you need to consume the stream and "peek" (or consume with `forEach`) using the given `FacetConsumer`. You can combine the "peek" with any other stream-related methods like mapping and filtering, so only those elements will be processed by the facet that are "seen" at that processing step in the stream._Implementation note_: As stated in the javadoc of `Stream.count()` you really need to consume the stream, whereas `Stream.count()` can take a shortcut to determine the number of elements of a stream. Comparing some javadocs, this behaviour was introduced in Java 9. This is why `forEach()` with a discarding consumer is used in this example.After processing all elements of the stream you can get a facet by name and from there the list of `FacetValue`s. A `FacetValue` holds both the attribute value (e.g the city name or age value) and the corresponding count. The default implementation `StandardFacet` will return the list of `FacetValue`s in descending count order.## Some thoughts on custom facet implementationsThe `StandardFacet` uses the `Object.hashCode()` method to determine which attribute values (for one attribute) are considered the same. You might want to implement your own variation of this bahaviour.The `StandardFacet` also only holds the attribute values obtained via the accessor function as attributes in `FacetValue`. You might need an implementation where the `FacetValue` also holds a list with references to all "source" objects with the same attribute value. In that case you need to write a custom facet and also return some custom `FacetValue`-derived class containing that object reference list.# Copyright / Licensej8tools is licensed under the MIT License## The MIT License (MIT)Copyright (c) NilsCodingPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE.